#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "functii.h"

void pix_read(FILE* f, struct pixel* x)
{
  fread(&x->B, 1, 1, f);
  fread(&x->G, 1, 1, f);
  fread(&x->R, 1, 1, f);
} //citire a parametrilor de culoare ai unui pixel

int compare(struct cluster* a, struct cluster* b)
{
  return a->ind - b->ind;
} //functie de sortare a clusterelor dupa ordinea gasirii lor

int main()
{
  FILE* intr = fopen("input.txt", "r");
  struct bmp_fileheader f_head;
  struct bmp_infoheader i_head;
  struct pixel ref, off;
  struct pixel **matrix, **matrix_cpy;
  char red, padding = 0;
  char output_name[20] = {"output.bmp"};
  double P;
  unsigned int i, j, k, **matrix_clus, nr_clus = 0;
  struct cluster *clus;

  fscanf(intr, "%hhu%c%hhu%c%hhu%c", &ref.R, &red, &ref.G, &red, &ref.B, &red);
  fscanf(intr, "%hhu%c%hhu%c%hhu", &off.R, &red, &off.G, &red, &off.B);
  fscanf(intr, "%lf", &P);

//Aici incepe cerinta 1:
  FILE* g1 =fopen("output.txt", "w");
  FILE* bmp = fopen("input1.bmp", "rb");
  //Citire date pentru file header:
  fread(&f_head, sizeof(struct bmp_fileheader), 1, bmp);

  //Citire date pentru image header:
  fread(&i_head, sizeof(struct bmp_infoheader), 1, bmp);
  i_head.biXPelsPerMeter = 0;
  i_head.biYPelsPerMeter = 0;

  //Generare matrice imagine:
  matrix = calloc(i_head.height, sizeof(struct pixel*));
  for(i = 0; i < (unsigned int)i_head.height; i++)
    matrix[i] = calloc(i_head.width, sizeof(struct pixel));

  matrix_cpy = calloc(i_head.height, sizeof(struct pixel*));
  for(i = 0; i < (unsigned int)i_head.height; i++)
    matrix_cpy[i] = calloc(i_head.width, sizeof(struct pixel));

  matrix_clus = calloc(i_head.height, sizeof(int*));
  for(i = 0; i < (unsigned int)i_head.height; i++)
    matrix_clus[i] = calloc(i_head.width, sizeof(int));

  clus = calloc(i_head.height * i_head.width, sizeof(struct cluster));

//Citim matricea imagine
  fseek(bmp, f_head.imageDataOffset, SEEK_SET);
  unsigned int poz = f_head.imageDataOffset;
  for(i = 0; i < (unsigned int)i_head.height; i++)
  {
    for(j = 0; j < (unsigned int)i_head.width; j++)
    {
      pix_read(bmp, &matrix[i][j]);
      matrix_cpy[i][j] = matrix[i][j];
    }
    poz += 3 * i_head.width + (4 - (3 * (i_head.width)) % 4) % 4;
    fseek(bmp, 0, poz);
  }

  //Afisam raspunsul pentru cerinta 1:
  struct param_clus x;
  x.f = g1;
  x.m = matrix;
  x.ref = ref;
  x.off = off;
  x.h = i_head.height;
  x.w = i_head.width;
  x.P = P;
  x.a = matrix_clus;
  x.v = clus;
  x.nr = &nr_clus;
  dim_clus(x);

//Aici incepe cerinta 2:
  char nFisOut[20];
  nFisOut[0] = 'o';
  nFisOut[1] = 'u';
  nFisOut[2] = 't';
  nFisOut[3] = 'p';
  nFisOut[4] = 'u';
  nFisOut[5] = 't';
  nFisOut[6] = '_';
  nFisOut[7] = 'b';
  nFisOut[8] = 'l';
  nFisOut[9] = 'u';
  nFisOut[10] = 'r';
  nFisOut[11] = '.';
  nFisOut[12] = 'b';
  nFisOut[13] = 'm';
  nFisOut[14] = 'p';
  nFisOut[15] = '\0';


  FILE* g2 = fopen(nFisOut, "wb");

//Afisam matricea blurata
  blur(matrix_cpy, i_head.height, i_head.width, clus, nr_clus, matrix_clus);
  fwrite(&f_head, sizeof(struct bmp_fileheader), 1, g2);
  fwrite(&i_head, sizeof(struct bmp_infoheader), 1, g2);
  for(i = 0; i < (unsigned int)i_head.height; i++)
  {
    for(j = 0; j < (unsigned int)i_head.width; j++)
    {
            fwrite(&matrix_cpy[i][j].B, 1, 1, g2);
            fwrite(&matrix_cpy[i][j].G, 1, 1, g2);
            fwrite(&matrix_cpy[i][j].R, 1, 1, g2);
    }
    for(k = 0; k < (4 - (3 * (i_head.width)) % 4) % 4; k++)
      fwrite(&padding, 1, 1, g2);
  }

//Aici incepe cerinta 3:
  qsort(clus, nr_clus, sizeof(struct cluster), compare);
  crop(matrix, clus, nr_clus, output_name);

  for(i = 0; i < (unsigned int)i_head.height; i++)
    free(matrix[i]);
  free(matrix);

  for(i = 0; i < (unsigned int)i_head.height; i++)
    free(matrix_cpy[i]);
  free(matrix_cpy);

  for(i = 0; i < (unsigned int)i_head.height; i++)
    free(matrix_clus[i]);
  free(matrix_clus);

  free(clus);

  return 0;
}
